读
df = pd.read_csv(url, sep='...', index_col='作为index的列名')
读取之前先观察数据特征，然后决定使用什么参数


df.shape
表格形状

df.columns
列名

df.dtype
数据类型名

df.info()
基本信息

df.head()/tail()/info
首/尾/首尾 信息

df.index
表格index

army.set_index('origin', inplace=True)
将某一列设为索引
inplace = True 改变原数据

df.groupby()
必须跟着数据处理函数
依某列成组，后面常接.agg()/transform()/apply分别处理各组
In[]:
price = chipo.groupby('item_name').agg({'price_per_item':'max'})
price.head()
Out[]:
                      price_per_item
item_name
6 Pack Soft Drink                6.49
Barbacoa Bowl                   11.75
Barbacoa Burrito                11.75
Barbacoa Crispy Tacos           11.75
Barbacoa Salad Bowl             11.89
price.take('Salad')

df.groupby(by=[...])依据多列分组
df = df.reset_index()注意常常用此转换索引为习惯形式

pipe
将函数应用于整个GroupBy对象,而不是每个组。

aggregate
对GroupBy对象应用聚合函数。

transform
对GroupBy对象逐列应用函数。

Series.apply
将一个函数应用于一个系列。

DataFrame.apply
对DataFrame的每一行或每一列应用一个函数


Series.map(arg, na_action=None)
根据输入映射或函数映射系列的值。
arg接收字典或函数

Series.apply
用于在系列上应用更复杂的函数。
不会改变原始数据

DataFrame.apply
按行/列应用一个函数。(默认按列）

DataFrame.applymap
在DataFrame的每一个元素上应用一个函数元素。

Series.agg
只执行聚合型操作。
drinks.groupby('continent').spirit_servings.agg(['mean', 'min', 'max'])
对spirit_servings同时执行三种操作

g = data.groupby(['occupation','gender']).gender.count()
occupation     gender     (这里没有overlapping index names)
administrator  F          36
               M          43
artist         F          13
               M          15

gender_ocup = users.groupby(['occupation', 'gender']).agg({'gender': 'count'})

                        gender（用agg才有）
occupation    gender
administrator F           36
              M           43
artist        F           13
              M           15

对指定列使用
gender_ocup = users.groupby(['occupation', 'gender']).agg({'gender': 'count'})

对所有列使用
occup_count = users.groupby(['occupation']).agg('count')

Series.transform
只执行转换类型操作。

unstack( level=- 1 , fill_value=None )
枢轴一个级别的(必然是分级的)索引标签。
Returns a DataFrame having a new level of column labels whose
inner-most level consists of the pivoted index labels

users.列.nunique()
# 等同于users.列.value_counts().count()
计算指定轴上的独特元素的数量。
返回带有不同元素数量的系列。可以忽略NaN值。

#value_counts()
df.列名.value_counts()
returns the count of unique elements
对所选列的不同对象进行计数
data.occupation.value_counts()
Out[11]:
occupation
student          196
other            105
educator          95
administrator     79
engineer          67
programmer        66


DataFrame.isin(values)
DataFrame中的每个元素是否包含在数值中
 df.isin([0, 2])
        num_legs  num_wings
falcon      True       True
dog        False       True

Series.isin(values)
系列中的元素是否包含在values
>>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',
...                'hippo'], name='animal')
>>> s.isin(['cow', 'lama'])
0     True
1     True
2     True
3    False
4     True
5    False

改变数据类型
chipo.item_price = chipo.item_price.apply(lambda x:float(x[1:-1]))
chipo.item_price = pd.to_numeric(chipo.item_price.str.slice(1))
chipo.item_price.str.slice(1) -> 对￥2.31进行切片

# 取所有7月数据
rqr['销售日期']=rqr['销售日期'].astype(str)
rdp[rdp['销售日期'].str.startswith('2020-07')]


df/列.describe( percentiles=None , include=None ,
                exclude=None , datetime_is_numeric=False )
描述性统计分析，返回一个包含统计结果的 DataFrame。
统计结果包括计数（count）、平均值（mean）、标准差（std）、
最小值（min）、四分位数（25%、50%、75%）和最大值（max）。


取两列元素
army[['veterans','deaths']]
army[army.origin=='veterans']取列

iloc
纯粹基于整数位置的索引,按位置选择
army.iloc[0]取行
army.iloc[:,1:4]取列
army.iloc[3:8,3:7]取行列


loc
通过标签或布尔数组访问一组行和列
army.loc[['Maine', 'Alaska'],['deaths', 'size' ,'deserters' ]]
army.loc[army.deaths>50] 取满足该条件的所有行列，等价于army[army.deaths>50]
army.loc[['Arizona','California']]取行
army.loc[:,'deaths'] 取列
army.loc[['Arizona','California'],'deaths']取行列

取单行单列结合使用
army.loc[:,'deaths'].iloc[-3]
army.loc['Arizona'].iloc[2]

bool下标取法 要求形状相同
chipo:
 #   Column              Non-Null Count  Dtype
---  ------              --------------  -----
 0   order_id            4622 non-null   int64
 1   quantity            4622 non-null   int64
 2   item_name           4622 non-null   object
 3   choice_description  3376 non-null   object
 4   item_price          4622 non-null   object

to get 'Salad' which is in the Column 'item_name':
chipo[chipo.item_name == 'Salad']
加强条件筛选
chipo[(chipo.item_name=='Canned Soda') & (chipo.quantity > 1)]

数据处理-----------------------------------------------------------------

合并数据
pd.concat
axis = 0按列增加行数
axis = 1按行增加列数
（对列按axis=0合并，新类形还是列，用 df = s.to_frame()）


pd.merge
按行索引增加列数

DataFrame.join


DataFrame.rename( mapper=None , * , index=None , columns=None , axis=None ,
                copy=None , inplace=False , level=None , errors='ignore' )
改变轴的标签（列/行标签）
使用映射：
df.rename(columns = {原名: 新名, 1: 'bathrs', 2: 'price_sqr_meter'}, inplace=True)
更改类型：
>>> df.index
RangeIndex(start=0, stop=3, step=1)
>>> df.rename(index=str).index
Index(['0', '1', '2'], dtype='object')

设置索引：
DataFrame.reset_index( level=None , drop=False , inplace =False , col_level=0 ,
            col_fill='' , allow_duplicates =_NoDefault.no_default , names=None )
重置指数,或其中的一个级别。
重置DataFrame的索引,并使用默认的索引。如果DataFrame有一个MultiIndex,本方法可以删除一个或多个级别

删除

简单删除列：
del df['name']

利用函数删除行/列
DataFrame.drop（标签=None，axis=0，index=None，columns=None，
                level=None，inplace=False，errors='raise'）
从行或列中删除指定的标签。
通过指定标签名称和相应的轴,或直接指定索引或列名来移除行或列。当使用多索引时,可以通过指定级别来删除不同级别的标签。


缺失值：
删除缺失的数值。
DataFrame.dropna（axis=0，how=_NoDefault.no_default，
thresh=_NoDefault.no_default，subset=None， inplace =False）

使用指定方法填写NA/NAN值
DataFrame.fillna( value=None , method=None , axis=None ,
                inplace=False , limit=None , downcast=None )



排序
chipo.item_name.sort_values()
chipo.sort_values(by = "item_name")
pandas.DataFrame.sort_values
默认返回一个排序后的视图（共享相同的底层数据。）,而不是在原始 DataFrame 上进行排序。
将 inplace 参数设置为 True，排序操作将直接在原始 DataFrame 上进行，而不会创建一个新的 DataFrame。

discipline.sort_values(['Red Cards', 'Yellow Cards'], ascending = False)
ascending True升序/False降序

在 Pandas 中，& 运算符主要用于对 DataFrame 或 Series
中的元素进行按位与运算，可以用于对特定列或数据框中的所有列进行操作。


遍历行：
for index, row in df.iterrows():
    f(index, row)

取部分行
discipline = euro12[['Team', 'Yellow Cards', 'Red Cards']]

保留小数位
round(float, 保留位数)

DataFrame.max( axis=_NoDefault.no_default , skipna=True , level=None ,
                numeric_only=None , **kwargs )
返回请求轴上的最大值。
如果您想要最大的索引，请使用 idxmax 。这等效于 numpy.ndarray 方法 argmax 。

names[names.Count == names.Count.max()]
idxmax( axis=0 , skipna=True , numeric_only=_NoDefault.no_default )
返回最大值在请求轴上首次出现的索引
crime.idxmax(0)
Out[34]:
（轴）                  （索引）
Population           2014-01-01
Violent              1992-01-01
Property             1991-01-01
Murder               1991-01-01
Forcible_Rape        1992-01-01

DataFrame.cummax( axis=None , skipna=True , *args , **kwargs )
返回DataFrame或Series轴的累计最大值

平均值在Count中出现的地方
names[names.Count == names.Count.median()]

缺失值在每列出现的次数
data.isnull().sum()
RPT    6
VAL    3
ROS    2
KIL    5
dtype: int64
未缺失值的个数
data.notnull().sum()
RPT    6568
VAL    6571
ROS    6572
KIL    6569
dtype: int64

字符串操作----------------------------------------------------------------------------
pandas.Series.str常用于列对象上，大多接受正则
支持功能：

大小写lower/upper/title/capitalize/swapcase

cat
将系列/索引中的字符串用给定的分隔符连接起来
join(sep)
用传递的定界符连接作为系列/索引中元素的列表

测试系列或索引的字符串中是否包含模式或regex (字符序列或正则表达式)contains
(NaN处理，'house|dog'多个参数， 大小写敏感)
match
类似,但更严格,依靠re.match而不是re.search。
Series.str.startswith
测试每个字符串元素的开始是否与模式匹配。
Series.str.endswith
与startwith相同,但测试字符串的末端
find( sub , start=0 , end=None )
返回系列/索引中每个字符串的最低索引
findall(pat, flags=0)
查找系列/索引中所有模式或正则表达式的出现
fullmatch( pat , case=True , flags=0 , na=None )
判断每个字符串是否完全匹配正则表达式

count(pat, flags=0)
计数

decode(encoding, errors='strict')
使用指定的编码对系列/索引中的字符串进行解码

encode(encoding, errors='strict')
使用指定的编码对系列/索引中的字符串进行编码

get(i)
get('name')在指定的位置或以指定的键从每个组件中提取元素。
get(1)从系列/索引中的每个元素的列表、图元、dict或字符串中提取元素

isalnum()
检查每个字符串中的所有字符是否为字母数字
Series.str.isalpha
检查是否所有的字符都是按字母顺序排列的。
Series.str.isnumeric
检查所有字符是否为数字。
Series.str.isalnum
检查所有字符是否为字母数字。
Series.str.isdigit
检查是否所有字符都是数字。
Series.str.isdecimal
检查所有字符是否为十进制。
Series.str.isspace
检查所有的字符是否都是空白。
Series.str.islower
检查所有字符是否为小写。
Series.str.isupper
检查所有字符是否为大写。
Series.str.istitle
检查是否所有字符都是标题大小写。

len()
计算系列/索引中每个元素的长度

ljust( width , fillchar=' ' )
在Series/Index中,在字符串的右侧进行填充


Series.str.strip
删除系列/索引中的前导字符和尾部字符。
s = pd.Series(['1. Ant.  ', '2. Bee!\n', '3. Cat?\t', np.nan, 10, True])
s.str.strip('123.!? \n\t')
Series.str.lstrip
删除系列/索引中的前导字符。
Series.str.rstrip
删除系列/索引中的尾部字符

pad( width , side='left' , fillchar=' ' )
在系列/索引中垫起字符串,宽度不限
 s.str.pad(width=10, side='both', fillchar='-')
0    -caribou--
1    --tiger---

repeat(repeats)
复制系列或索引中的每个字符串

replace( pat , repl , n=- 1 , case=None , flags=0 , regex=None )
替换系列/索引中出现的每个模式/regex

split( pat=None , n=- 1 , expand=False , * , regex=None )
用给定的分隔符/定界符分割字符串

slice( start=None , stop=None , step=None )
从 "系列 "或 "索引 "中的每个元素中切出子串
slice_replace( start=None , stop=None , repl=None )
用另一个值替换一个字符串的位置片断

日期操作----------------------------------------------------------------------------------
import pandas as pd
import datetime
python自带的日期类型到pandas中是object，需要转换pd.to_datetime()


转换为日期类型
crime.Year = pd.to_datetime(crime.Year, format='%Y')
(若不加%Y则全都会变成1970-01-01 00:00:00.000001960)
Year  Population     Total  ...  Burglary  Larceny_Theft  Vehicle_Theft
0  1960-01-01   179323175   3384200  ...    912100        1855400         328200
1  1961-01-01   182992000   3488000  ...    949600        1913000         336000
2  1962-01-01   185771000   3752200  ...    994300        2089600         366800
...

划分时间，随后对取样的每相邻两个间的数据进行聚合操作
DataFrame.resample( rule , axis=0 , closed=None , label=None , convention='start' ,
kind=None , loffset=None , base=None , on=None , level=None , origin='start_day' ,
offset=None , group_keys=_NoDefault.no_default )
重新取样时间序列数据。
用于时间序列的频率转换和重新取样的方便方法。该对象必须有一个类似于数据时间的索引
(DatetimeIndex,PeriodIndex, orTimedeltaIndex)，
或者调用者必须将类似日期时间的系列/索引的标签传递给 on / level 关键字参数。
示例
# Uses resample to sum each decade
crimes = crime.resample('10AS').sum()
# Uses resample to get the max value only for the "Population" column
population = crime['Population'].resample('10AS').max()
# Updating the "Population" column
crimes['Population'] = population
#以下两者作用相同
data.resample('W').mean()/data.groupby(data.index.to_period('W')).mean()


以日期为索引时，取每年第一个月求其每一列的平均值
data.loc[data.index.month == 1].mean()

时间段：
DataFrame.to_period( freq=None , axis=0 , copy=True )
将DataFrame从DatetimeIndex转换为PeriodIndex。
将DataFrame从DatetimeIndex转换为具有所需频率的PeriodIndex(如果没有通过,则从索引中推断)
'https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases'
data.groupby(data.index.to_period('Y')).mean()


-----------------------------------------------------------------------------------
# 显示设置
import pandas as pd
#显示所有列
pd.set_option('display.max_columns', None)
#显示所有行
pd.set_option('display.max_rows', None)

#显示1000列
pd.set_option('display.max_columns', 1000)
#显示1000行
pd.set_option('display.max_rows', 1000)
#设置每一列中值的最大显示宽度
pd.set_option('display.max_colwidth',1000)
#设置浮点数的最多显示精度
pd.get_option('display.precision')  # 6
pd.Series(data = [1.23456789])
pd.set_option('display.precision',4)
pd.Series(data = [1.23456789236546])